So, when you access the files, we talked about the IOUtil, it gives you some simple functions. But if you want to have a little bit more precise control over file access, then you're probably going to use the OS Package. The OS Package provides a bunch of functions to access files too and you have more control. So, with IOUtil you could read the whole file and write the whole file, who knows about it. With OS Package you can do a little bit more, read a little bit, write a little bit, do different things. So, here are some of the functions in there. First, you've got os.Open that opens a file. So, you pass it the name of the file and it'll return a file descriptor. A file struck basically, I'll call it F, let's say. It will turn a file descriptor that you can use to access the file. Now, os.Close, it closes the file when you're done. Os.Read reads from a file into a byte array. Okay? Now, and it reads to fill the byte array. So, you can control how much you read unlike with read file IOUtil you had to read the whole file. If you only want to read ten bytes out of it, you can make a byte array of size 10, and pass that to read, and read will fill that byte. So, read 10 out. Read however how much you need to fill the byte array. Write is a similar thing. You can take a byte array and write that into a file and it'll just right as much as the byte array is long. So, here's an example of a file reading using the OS Package. So, first thing we do is we open the file. So, we call os.Open, pass it the name of the file which is completely arbitrary. So, we pass this file dt.txt. It opens it. It returns this F, this file handle that we can use to access the file. If there's an error like the file doesn't exist, it's something like that, then it'll throw an error, but otherwise it'll return this file handle. Now, for this file I want to read, right? I want to read into some byte array. So, let's say, I want to read 10 bytes out of this file. So, I can make a byte array, b, array, colon, equal, make, a call make. I make it a byte, I give it the type, and I say, comma, 10. So, now I have this byte array, empty byte array. Then, I can call f.Read. F is the file handle that was returned by open. Call f.Read pass it the byte array as the argument, and it will then fill that byte array with the first bytes out of this file. Now, note that if I call it again with that same byte array, it would fill byte array with the next 10, right? Every time, the head of the read head actually moves. So, I read the first 10. If I read again, it's not going to read the first ten again, it will be the next 10 until I close it and resets the head. This function returns two things an error, if there's an error. So, if you're trying to read something and you're out of space, as empty or something like that, you reject file might throw an error, but otherwise it returns NB which is the number of bytes that I read. That sometimes the number of byte should be equal to the size of the byte array, but it doesn't have to be, you can have what's called a short read. Maybe the byte array is size 10, but there are only five byte sets left in the file, then you only read five out. So, nb would equal five in that case. Then, when you're done reading, you just call f.Close and it closes the file, and resets the head for the next time. So, next example is Write. This time using the OS Package as well. So, first thing we're going to do, is we want to write a byte array into a file. So, we first create the file on this case, os.Create. We could have opened the file, we could have opened the existing file and open it to append to it. But in this case we're just going to create just for an example. We're going to create a new, calling outfile.txt and then we get this file handle f that refers to that file. Then, we make a byte array with using a, sorry. Actually this is a slice, but we make a slice by calling b array, but this slice has three elements in it. One, two, three, we want to write these. So, we call write, f.Write, f dot write, we pass it the byte array and it just writes those three bytes into the file. Now, another thing that we can do, there's another function for writing called WriteString that takes an entire string instead of a byte array it takes explicit string and writes that. So, you can call WriteString, write, "Hi" or something like that, pass it a string, it writes that into the file and which has to be a Unicode Sequence.