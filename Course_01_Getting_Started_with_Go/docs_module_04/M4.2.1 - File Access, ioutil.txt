So, files are very commonly used in programs and used to trade data between programs. So, we're going to talk about how Golang allows us to access files. We'll give an overview anyway. Now, file access, and this is true in all languages, file access is linear access, not random access. So, the reason for this is because files, when they were originally defined, they were actually stored on tapes, right? Physical tapes. When you access a tape, you remember, it depends how old. But I used to have cassette tapes. Or big old tapes, you see them in movies, science fiction movies, big old tapes, right? They turn this physical tape that is on as linear access. Meaning, the beginning of the file is at one point of the tape, the end of the file is way over here at the other point of the tape. So, if you want to access it, you got to start, you read one point of the tape, and you got to turn the tape and read the next point. Turn the tape, read the next point, and so on. So, it's always linear access. Wherever the turning limits it. This is mechanical operation of physically turning the tape to access the next piece of the file, right?. So, it's always linear access. If you want to just access something at the beginning then something at the end, that would waste a lot of time. The beginning is here, then you've got to take a lot of time turning to get to the end, right? Instead, you read it linearly. You'll say, ''Okay, I'm at the beginning and I read everything in that vicinity.'' You read from the beginning to the end. So, that's how file access still is today. Even though, you don't necessarily have this linear access constraint. I mean, if you look at physical disks, they still have linear access, right? There's still tracks, and you have to go through the whole track. So, there's still some linear access in that, but for all we know a file might be in a random access device. So, for instance a flash memory or something like that, solid-state drive, right? That's actually a random access device, but still the way that we access files in programs is as if it's a linear access device. So, normally when you access files, you get in other languages too, you get this set of basic operations that are common for file access. So, first one is open. It's getting a handle tests start accessing the file, you have to open the file first. Then you always get a read function or some variety of read functions, where you can read bytes from the file and read them into like say a byte array. Write, where you write data from a byte array and move that into a file. Close, is when you're done, you close the file because you're done reading it or accessing it. Then seek, is another thing, a common thing to have. Seek basically moves your read head. So, what that means is it's linear access, right? So, you read from the beginning to the end, but sometimes you really do need to skip to a certain point and seek does that. So, these are very common functions that you see basically in any language to access files. So, there's more than one package in Go, that allows you to access files. It has functions in it that allow file access. We'll start with the ioutil package. ioutil package has some basic file access functions. Basic, they're easy, they're nice to use. If the basics are enough for you, ioutil is great. So, the first function you get there is a ReadFile. Now ReadFile, you'll notice it ioutil.ReadFile, it takes as an argument the name of the file you want to read. That can arbitrary test.txt or whatever you want to call it. It returns two things, data basically byte array, and then an e is the error, so it returns two things. An error is only if there's some error reading but if there isn't an error, its main job is to return this byte array, which is the first thing that it returns. So, what it does is pretty simple. It just reads the whole file and returns the contents of the whole file into a byte array, and then you can manipulate the byte array. Now, when you use ReadFile, you don't have to do an explicit open or close. You don't have to open the file at the beginning, close it at the end. That's all built into the ReadFile function. So, it will just open the file, read the whole thing, and then close it. So, it's nice. One issue with it is that large files can be an issue. So, when I say it cause a problem, it's not going to cause an error, but files can be gigantic. Okay. I mean, if you think about the size of a disk, the disk can be terabytes, right? I mean, I have a terabyte disk in my machine, right? That's normal, right? So, you can have giant size files. You can have files that really take up most of your memory. Because when you read a file, it takes it off of whatever the storage devices, let's assume you are using disk for a second, okay. Say, I put it on disk, but it could be solid-state storage too. It takes it, and it reads it into RAM, into its main memory. Now, main memory is much more limited. So, my disk, I might have a couple of terabytes, but my RAM I might only have eight gigabytes. So, I could have a file at eight gigabyte long file in my disk, that I tried to read into main memory. If I read that whole file, I'm using up my whole RAM and my machine will choke. I can't run anything because I've used up all my memory. So, when you have large files, ReadFile you can't use it. But if your files are small enough so that it doesn't hog up all the memory, then ReadFile is fine. You can just read the whole thing in at once. Now, ioutil also has a WriteFile function which is complementary to the ReadFile and if you look at WriteFile, it takes, let's say it just takes three arguments. First argument, is the name of the file you're going to write to. The second argument, is the byte array or as a string and then the third argument, is the permission. So, remember WriteFile, is actually creating a new file. So, when I call WriteFile here, I'm going to create a new file called outfile.txt, and it's going to write the data ''Hello, World'' into that file. When it creates that file, it has to give that file permissions, read and write access permissions. So, it's using unix-style permission bytes. So, seven, seven, seven means permission for everybody. Everybody can do everything. But, you can adjust the permissions that you see fit, but those are the arguments to WriteFile. So again, it writes. Now remember WriteFile is not flexible. You can append to a file or something, you can't say, ''Oh! Let me just add onto the file.'' WriteFile, it just creates a file, dumps everything, the whole string, or the whole byte array into that file, and then closes the file.